=head1 NAME

Template::Plex - Templates with (P)erl and (Lex)ical Aliasing

=head1 SYNOPSIS

	use Template::Plex;

	#Data for templates alias and access
	my $base_data={name=>"James", age=>"12", fruit=>"banana"};

	#Options  alter template runtime
	my %options = (
		root=>"path/to/templates/dir"
		no_include=>undef
	);

	#The actual template text
	my $inline_template='$name\'s age $age and favourite fruit is $fruit'

	#Preparing the template in Template::Plex object
	my $t=plex [$inline_template], $base_data, %options;


	#Render with the values aliased in $base_data
	$t->render();		
	#
	#=> 	James's age is 12 and favourite fruit is banana

	#Update the data in the hash used during preparation.
	$base_data->{qw<name,fruit>}=qw<John apple>;

	#Rendering again will use updated aliased values
	$t->render();		
	#
	#=>	John's age is 12 and favourite fruit is apple


=head1 DESCRIPTION

This module is a small mechanism to facilitate the use of perl (not embedded
perl) as a text processing template language. 

Conceptually, a Plex template is just complex string in double quoted context,
with the outer operators removed. So instead of
	
	#PERL
	"This is is a perl string interpolating @{[ map uc, qw<a b c d>]}"

	#  or

	qq{This is is a perl string interpolating @{[ map uc, qw<a b c d>]}}
	

	#PLEX template. Same as PERL syntax, without the outer double quotes
	This is is a perl string interpolating @{[ map uc, qw<a b c d>]};

	#OUTPUT is the same for all of the above:
	This is is a perl string interpolating A B C D

Because of the powerful and flexible interpolation of strings in perl, you can
do just about anything in in the templates. After all the template is just perl

Some feature highlights:

=over

=item * Templates are written in perl syntax

=item * Template is compiled into a subroutine

=item * Optional lexical aliasing for style and performance

=item * 'Include' Templates within templates easily

=item * Recursive and conditional sub templates loading

=item * Declare variables and subroutines in templates

=item * C<use> other modules direclty in templates

=back

=head1 MOTIATION

=over

=item *

So many templating systems available, none use perl as the template language?

=item * 

Lexical aliasing allows the input variables to be accessed directly by name
(i.e. C<$name>) instead of as a member of a hash (i.e. C<$fields-\>{name}> ) or
by delimiting with custom syntax


=item * 

The perl syntax C<@{[...]}>  will to execute arbitrary perl statements in a
double quoted string.  It is only 1 more character then many other template
languages custom syntax to execute perl statements in a template.

=item * 

Other templating system are very powerful, but have huge a huge APIs. This Plex
leverages perl to be more consise

=back

=head1 API

=head2 C<plex>
	
	plex $path, $variables_hash, %options
	
A short hand for loading and preparing  a template. It is a simple wrapper
around C<new> . Please see C<new> below for details.

=head2 C<new>

	Template::Plex->new($path, $variables_hash, %options

Creates a new instance of a template, loaded from a scalar, file path or an
existing file handle. Template is prepared and ready to be rendered after
creation. The arguments are detailed below:

=over 

=item C<$path>

This is a required argument.

If C<$path> is a string, it is treated as a file
path to a template file. The file is opened and slurped with the content being
used as the template

If C<$path> is filehandle, or GLOB ref, it is slurped with the content being
used as the template. Can be used to read template stored in C<__DATA__> for
example

If C<$path> is an array ref, the items of the array are joined into a string,
which is used directly as the template.

=item C<$variables_hash>

This is a required argument but can be C<undef>.

The C<$variables_hash> provides variables to the template. It is aliased to C<%fields> variable (note the %) and directly usable in the template like a normal hash e.g. C<$fields{name}>

In addition, the top level items of the C<%fields> hash are also aliased into
the template using the key name (key names must be valid for a variable name
for this to operate)

This allows an element such as C<$fields{name>}> to be  directly accessible as
C<$name>.

It also means any external modification of the items in C<$variable_hash> will
be visible in the template.

If the C<$variables_hash> is undef, then no variables will be lexically
aliased. The only variables accessible to the template will be via the
C<render> method call

=item Options

These are non required arguments, but must be key value pairs when used.

Options are stored lexically in the rendering sub in the variable C<%options>
for recursive C<plex> calls within a template.

Currently supported options are:


=over

=item B<root>

C<root> is a directory path, which if present, is prepended to to the C<$path>
parameter.  


=item B<no_include>

Disables the uses of the preprocessor include feature. The template text will
not be scanned  and will prevent the C<include> feature from operating.
See C<include> for more details

This doesn't impact recursive calls to C<plex>  or C<new> to
dynamically/conditionally load templates.

=back

=item Return value

The return value is C<Template::Plex> object which can be rendered using the C<render> method

=item Example Usage
		my $hash={
			name=>"bob",
			age=>98
		};

		my $template_dir="/path/to/dir";

		my $obj=plex "template.plex", $hash, root=>$template_dir;

=back

=head2 C<render>

	$obj->render($fields);

This object method renders a template object created by C<new> or C<plex> into
a string. It takes an optional argument C<$fields> which is a reference to a
hash containing field variables. C<fields> is aliased into the template as
C<%fields> which is directly accessible in the template

	eg
		my $more_data={
			name=>"John",
		};
		my $string=$template->render($more_data);
		
		#Template:
		My name is $fields{John}

Note that the lexically aliased variables from the C<new> and C<plex> are
independent to the C<%fields> variable and can both be used simultaneously in a
template

=head2 C<include>

	@{[include("path")}]

	where $path is path to template file to inject

Used in templates only.

This is a special directive that substitutes the text B<@{[include("path")]}> with
the contents of the file pointed to by path. This is a preprocessing step which
happens before the template is prepared for execution


This API is only available in templates. If C<root> was included in the options
to C<plex> or C<new>, then it is prepended to C<path> if defined.

When a template is loaded by C<new> or C<plex> the processing of this is
subject to the C<no_include> option. If C<no_include> is specified, any
template text that contains the C<@{[include("path")}]> text will result in a
syntax error

=head1 PLEX TEMPLATE SYNTAX

Well, its just perl. Seriously. But if you aren't grasping the concept just
yet, a L<Template::Plex> template is a perl program with the two following
constraints:

=over 

=item * The program consists only of perl syntax permissible in a double quoted string

=item * The outermost double quote operators are ommited from the program/template

=back

This is best illustrated by example. Suppose the following text is stored in a
file or in the C<__DATA__ > section:

	The pot of gold at the end of the rainbow has $amount gold coins
	As for the rainbow, the colors are:
	@{[ map ucfirst."\n", @$colors ]}
	Good day!

Everything in the text is valid syntax in double quote operator, but the outer
double quote operator is omitted.

Or in other words, the template looks like plain text, but with double quoted
added, it is valid perl code.

Neat!

Following sections show example of particular scenarios

=head2 Access to Existing Scalars, Arrays and Hashes

If C<$variables_hash> was supplied during a C<new> or C<plex> call, the top
level element will be accessible as normal scalars in the template. 


	This template uses a scalar $name that was lexically aliased
	Here the same variable can be accessed via $fields{name}	
	Calling render with an hash argument will override the $fields{name}

	access the array element $array->[$index]
	Accessing element $hash->{key} just for fun


=head2 Executing a single (or list) of Statements

To achieve this, a neat trick is to dereference an inline reference to an
anonymous array. That is C<@{[...]}>. The contents of the array is then the
result of the statements.  Sounds like a mouthful, but it is only a couple of
braces and lets you do some powerful things:

	Calling a subrotine @{[ my_sub() ]}
	Declaring a variable @{[ my $variable=1; ]};	
	Doing math a + b = @{[ $a+$b ]}
	Building an array @{[ uc("red"),uc("blue")]}
	Mapping @{[ join "\n", map uc, @items]}
	

=head2 Executing Multiple Statements

When a single statement won't do, the C<do{}> construct executes a block, which
can have any number of statements and returns the last statement executed into
the template

	Executing multiple statments @{[ do {
	 	my $a=1; 
		$a++; 
		($a,-$a)

	} ]} in this template

=head2 Using/Requiring Modules

Again standard perl syntax for the win

	Template will call hi res time 
	The time is: @{[ time ]}
	@{[ BEGIN {
		use Time::HiRes qw<time>;
		}
	]}

=head2 Declaring Variables

TODO
Variables can be declared in the C<@{[..}]> container. 



=head1 MORE ON LEXICAL ALIASING

Any keys present in the hash when C<plex> is called are used to construct
lexical variables which are aliases to the hash elements of the same key name.
The hash itself is also aliased to a variable called C<%fields> 

So for a C<$base_data> hash like this:

	my $base_data={name=>"jimbo", age=>10};

The template can access the fields "name" and age like this:

	my $template='my name is $name an I am $age';

or like this:
	
	my $template='my name is $fields{name} and I am $fields{age}';

The first uses the lexical variables to skip the hash lookup, and simpler
style.  The caveat is that all fields must exist at the time the template is
prepared.

To change the values and render the template, the same C<$base_data> variable
must be manipulated. i.e.

	$base_data->{name}="Tim";
	$render->();

This still performs no hash lookups in the rendering and is a very quick way of
rendering the changing data.


=head2 NOT USING LEXICAL ALIASING 

If the data to apply to the template completely changes, it can be passed as a
hash ref to the render code reference.

	my $new_variable={name=>data};
	$render->($new_variable);

However to use this data the template must be constructed to access the fields
directly:

	my $template='my name is $fields{name} and I am $fields{age}';

=head2 HYBRID ACCESS

This is interesting. The template can refer to the lexical aliases and the
direct fields at the same time. The lexical aliases only refer to the data
provided at preparation time, while the field refer to the latest data
provided:

	my $template='my name is $fields{name} and I am $age
	my $base_data={name=>"jimbo", age=>10};
	my $override_data={name=>"Eva"};

	my $render=plex $template, $base_data;
	my $string=$render($override_data);
	#string will be "my name is Eva and I am 10


=head1 SECURITY

This module uses C<eval> to generate the code ref for rendering. This means
that your template, being perl code, is being executed. If you do not know what
is in your templates, then maybe this module isn't for you.

To mitigate the security risk, the rendering code refs should be generated  and
cached, so they are not needing to be run during normal execution. That will
provide faster rendering and also, prevent unknown templates from accidentally
being executed.


=head1 SEE ALSO

Yet another template module right? 

Do a search on CPAN for 'template' and make a cup of coffee.


=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 by Ruben Westerberg

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, or under the MIT license

=cut
