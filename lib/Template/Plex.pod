=head1 NAME

Template::Plex - Templates in (P)erl using (Lex)ical Aliasing

=head1 SYNOPSIS

Import C<plex> and C<plx> into you package:

	use Template::Plex;

Setup variables/data you want to alias:

	my $vars={
		size=>"large",
		slices=>8,
		people=>[qw<Kim Sam Harry Sally>
		]
	};
	local $"=", ";

Write a template:

	Ordered a $size pizza with $slices slices to share between @$people and myself.
	That averages @{[$slices/(@$people+1)]} slices each.

Load a template with C<plex>:

	my $template= plex "path_to_template", \%vars;

Render it:
	my $output=$template->render;	

	#OUTPUT
	Ordered a large pizza with 8 slices to share between Kim, Sam, Harry, Sally and myself.
	That averages 1.6 slices each.     
	

Change values and render it again:

	$vars->{size}="extra large";
	$vars->{slices}=12;
	
	$output=$template->render;

	#OUTPUT
	Ordered a extra large pizza with 12 slices to share between Kim, Sam, Harry, Sally and myself.
	That averages 2.4 slices each.


=head1 DESCRIPTION

Conceptually, a C<Template::Plex> template is just a string returned from a
subroutine in perl's double quoted context, with the outer operators removed:
	
	#PERL
	"This is is a perl string interpolating @{[ map uc, qw<a b c d>]}"

	#  or

	qq{This is is a perl string interpolating @{[ map uc, qw<a b c d>]}}
	

	#PLEX template. Same as PERL syntax, without the outer double quotes
	This is is a perl string interpolating @{[ map uc, qw<a b c d>]};

	#OUTPUT is the same for all of the above:
	This is is a perl string interpolating A B C D

Working from this knowledge, this module facilitates the use of perl (not
embedded perl) as a text processing template language and system capable of
loading, caching and rendering powerful templates. The following are actual
templates demonstrating some of the feature:

=over

=item * Templates are written in perl syntax:

	This template is a valid $perl  code @{[ uc "minus" ]} the outer quotes

=item * Templates are compiled into a perl subroutine, optionally cached

	Sub/template is loaded only the first time in this map/loop
	subsequent calls to plx use the cached template

	@{[map {plx "path_to_template",{}} qw< a b c d e >]}
		

=item * Lexical and package variables accessed/created within templates

	@{[
		block {
			$input_var//=1; #set default

		}

	}]
	
	Value is $input_var;

=item * Call and create subroutines within templates:

	@{[
		block {
			sub my_great_calc {
				my $input=shift;
				$input*2/5;
			}
		}

	}]

	Result of calculation: @{[my_great_calc(12)]}

=item * 'Include' Templates within templates easily:
	
	@{[include("path_to_file")]}

=item * Recursive sub template loading
	
	@{[ plx "path_to_sub_template" ]}

=item * Conditional rendering

	@{[ $flag and $var]}

	@{[ $flag?$var:""]}

=item * Lists/Loops/maps
	
	template interpolates @$lists directly
	

=item * C<use> other modules directly in templates:

	@{[
		block {
			use Time::HiRes qw<time>
		}
	]}

	Time of day right now: @{[time]}

=back

Because of the powerful and flexible interpolation of strings in perl, you can
do just about anything in a Plex template. After all the template is just perl. 

The 'lexical' part of this modules refers to ability of variables to be
aliased into the template (more on this later). It improves the style and usage
of variables in a template while also allowing sub templates to access/override
variables using lexical scoping.

Some feature highlights:


The synopsis example is only scratching the surface in terms of features. For
more examples, checkout the examples directory in this distribution. I hope to
add more in the future

=head1 MOTIATION

=over

=item *

So many templating systems available, yet none use perl as the template language?

=item * 

Lexical aliasing allows the input variables to be accessed directly by name
(i.e. C<$name>) instead of as a member of a hash ref (i.e.
C<$fields-E<gt>{name}>) or by delimiting with custom syntax (i.e. C<E<lt>%= name %E<gt>>)

=item * 

The perl syntax C<@{[...]}>  will execute arbitrary perl statements in a double
quoted string. 

=item * 

Other templating system are very powerful, but have huge a huge APIs and
options. L<Template::Plex> could have a very minimal API with perl doing the
hard work

=back

=head1 TODO

=over 

=item * More tests

=item * Add a guide document

=item * CLI app to render .plex files

=back

=head1 API

=head2 C<plex>
	
	plex $path, $variables_hash, %options
	
Creates a new instance of a template, loaded from a scalar, file path or an
existing file handle. 

=over 

=item C<$path>

This is a required argument.

If C<$path> is a string, it is treated as a file path to a template file. The
file is opened and slurped with the content being used as the template.

If C<$path> is a filehandle, or GLOB ref, it is slurped with the content being
used as the template. Can be used to read template stored in C<__DATA__> for
example

If C<$path> is an array ref, the items of the array are joined into a string,
which is used directly as the template.



=item C<$variables_hash>

This is an optional argument but if present must be an empty hash ref C<{}> or
C<undef>.

The top level items of the C<$variables_hash> hash are aliased into the
template using the key name (key names must be valid for a variable name for
this to operate). This allows an element such as C<$fields{name>}> to be
directly accessible as C<$name> in the template and sub templates.

External modification of the items in C<$variable_hash> will be visible in the
template. This is thee primary mechanism change inputs for subsequent renders
of the template.

In addition, the C<$variables_hash> itself is aliased to C<%fields> variable
(note the %) and directly usable in the template like a normal hash e.g.
C<$fields{name}>

If the C<$variables_hash> is an empty hash ref C<{}> or C<undef> then no
variables will be lexically aliased. The only variables accessible to the
template will be via the C<render> method call.

=item C<%options>

These are non required arguments, but must be key value pairs when used.

Options are stored lexically for access in the template in the variable
C<%options>. This variable is automatically used as the options argument in
recursive calls to C<plex> or C<plx>, if no options are provided


Currently supported options are:


=over

=item B<root>

C<root> is a directory path, which if present, is prepended to to the C<$path>
parameter if C<$path> is a string (file path).


=item B<no_include>

Disables the uses of the preprocessor include feature. The template text will
not be scanned  and will prevent the C<include> feature from operating.
See C<include> for more details

This doesn't impact recursive calls to C<plex> or C<plx> when dynamically/conditionally
loading templates.

=item B<no_block_fix>

Disables removing of EOL after a C<@{[]}> when  the closing C<}]> starts on a
new line. Does not effect C<@{[]}> on a single line or embedded with other text

	eg	
		
		Line 1
		@{[
			""
		]}		<-- this NL removed by default
		Line 3	
	
In the above example, the default behaviour is to remove the newline after the
closing C<]}> when it is on a separate line. The rendered output would be:


		Line1
		Line3

If block fix was disabled (i.e. C<no_block_fix> was true) the output would be:


		Line1

		Line3



=item B<package>

Specifies a package to run the template in. Any C<our> variables defined in
the template will be in this package.  If a package is not specified, a unique
package name is created to prevent name collisions

=back

=item Return value

The return value is C<Template::Plex> object which can be rendered using the
C<render> method

=item Example Usage
		my $hash={
			name=>"bob",
			age=>98
		};

		my $template_dir="/path/to/dir";

		my $obj=plex "template.plex", $hash, root=>$template_dir;

=back

=head2 C<plx>

	plex $path, $variables_hash, %options

Arguments are the same as C<plex>.  Similar to the C<plex> subroutine, however
it loads, caches and immediately executes the template.  Somewhat equivalent
to:

	state $template=plex ...;
	$template->render;

The template is cached so that next time C<plx> is called from the same
file/line, it reuses the code.

Makes using recursive templates very easy, however does have the slight
overhead of generating cache keys and actually performing the cache lookup




=head2 C<render>

	$obj->render($fields);

This object method renders a template object created by C<plex> into
a string. It takes an optional argument C<$fields> which is a reference to a
hash containing field variables. C<fields> is aliased into the template as
C<%fields> which is directly accessible in the template

	eg
		my $more_data={
			name=>"John",
		};
		my $string=$template->render($more_data);
		
		#Template:
		My name is $fields{John}

Note that the lexically aliased variables setup in C<plex> or C<plx> are independent to the
C<%fields> variable and can both be used simultaneously in a template

=head2 C<include>

	@{[include("path")}]

	where $path is path to template file to inject

Used in templates only.

This is a special directive that substitutes the text similar to
B<@{[include("path")]}> with the contents of the file pointed to by path. This
is a preprocessing step which happens before the template is prepared for
execution


This API is only available in templates. If C<root> was included in the options
to C<plex>, then it is prepended to C<path> if defined.

When a template is loaded by C<plex> the processing of this is
subject to the C<no_include> option. If C<no_include> is specified, any
template text that contains the C<@{[include("path")}]> text will result in a
syntax error

=head2 block

	block { ... }

A subroutine which executes a block just like the built in  C<do>. However it
always returns an empty array ref (C<[]>).

When used in a template in the C<@{[]}> construct, arbitrary statements can be
executed. However, as a reference to an empty array is returned, perl's
interpolation won't inject 'last statement' values into your template.

If you DO want the last statement returned into the template, use the built in
C<do>.

	eg
		
		@{[
			# This will assign a variable for use later in the template
			# but WILL NOT inject the value 1 into template when rendered
			block{
				$i=1;
			}

		]}


		@{[
			# This will assign a variable for use later in the tamplate
			# AND immediately inject '1' into the template when rendered
			do {
				$i=1
			}

		]}



=head1 PLEX TEMPLATE SYNTAX \w EXAMPLES

Well, its just perl. Seriously. But if you haven't grasped the concept just
yet, a L<Template::Plex> template is a perl program with the two following
constraints:

=over 

=item * consists only of perl syntax permissible in a double quoted string

=item * outermost double quote operators are ommited from the program/template

=back

This is best illustrated by example. Suppose the following text is stored in a
file or in the C<__DATA__ > section:

	The pot of gold at the end of the rainbow has $amount gold coins
	As for the rainbow, the colors are:
	@{[ map ucfirst."\n", @$colors ]}
	Good day!

Everything in the text is valid syntax withing double quote operators, but the outer
double quote markers are omitted.

Or in other words, the template looks like plain text, but with double quoted
added, it is valid perl code.

Neat!

Following sections show example of particular scenarios

=head2 Access to Existing Scalars, Arrays and Hashes

If C<$variables_hash> was supplied during a C<plex> call, the top level
elements will be aliased and accessible as normal scalars in the template. 


	This template uses a scalar $name that was lexically aliased
	Here the same variable can be accessed via $fields{name}	
	Calling render with an hash argument will override the $fields{name}
	AReallylong${word}WithAVariable

	access the array element $array->[$index]
	Accessing element $hash->{key} just for fun


=head2 Executing a single (or list) of Statements

To achieve this, a neat trick is to dereference an inline reference to an
anonymous array. That is C<@{[...]}>. The contents of the array is then the
result of the statements.  Sounds like a mouthful, but it is only a couple of
braces and lets you do some powerful things:

	Calling a subrotine @{[ my_sub() ]}
	Doing math a + b = @{[ $a+$b ]}
	Building an array @{[ uc("red"),uc("blue")]}
	Mapping @{[ join "\n", map uc, @items]}
	Conditional interpolation @{[ $var and "insert on true"]}
	

=head2 Executing Multiple Statements

When a single statement won't do, the C<do{}>  or C<block> construct executes a
block, which can have any number of statements; C<do> returns the last
statement into the template where as block does not

	Executing multiple statments @{[ do {
	 	my $a=1; 
		$a++; 
		($a,-$a)

	} ]} in this template

=head2 Using/Requiring Modules

Again standard perl syntax for the win. C<BEGIN> block is executed as early as
possible, before the rest of the template executes

	Template will call hi res time 
	The time is: @{[ time ]}
	@{[ block {
		BEGIN {
			use Time::HiRes qw<time>;
		}
	}
	]}

=head2 Declaring Variables

Variables can be declared in the C<@{[..}]> container.

C<my> variables will only be visible within the C<@{[..]}> block it was defined.
	
	eg	#render a mini single line template with my variable
		@{[ do {
			my $a=time;
			$a+=23;
			"Time is: $a";	
		} }]

C<our> variables can be used instead of C<my> variables and are visible
throughout the current template, including recursively used templates

	eg
		@{[ do {
			our $a=time;
			"";
		} }]
		
		Template package variable is $a

		@{[ do {
			$a+=23:
			""
		} ]}
		Updated template package variable is $a

Sub templates loaded with C<include> and recursive C<plex> calls will have
direct access to package variables created in the template. A new unique
package is created for each top level use of plex to prevent name collisions.


=head1 TIPS ON USAGE

=head2 Points to note

=over 

=item * Aliasing is a two way steet

Changes made to aliased variables external to the template are available inside
the template (one of the main tenets of this module)

Changes make to aliased variables internal to the template are available outside
the template.

=item * Unbalanced Delimiter Pairs

Perl double quote operators are smart and work on balanced pairs of delimiters.
This allows for the delimiters to appear in the text body without error.

However if your template doesn't have balanced pairs (i.e. a missing "}" in
javascript/c/perl/etc), the template will fail to compile and give a strange
error.

If you know you don't have balanced delimiters, then you can escape them with a
backslash

Currently L<Template::Plex> delimiter pair used is B<{ }>.  It isn't changeable in
this version.

=item  * Are you sure it's one statement?

If you are having trouble with C<@{[...]}>, remember the result of the last
statement is returned into the template.

Example of single statements

	@{[time]}			#Calling a sub and injecting result
	@{[$a,$b,$c,time,my_sub]}	#injecting list
	@{[our $temp=1]}		#create a variable and inject 
	@{[our ($a,$b,$c)=(7,8,9)]}	#declaring a

If you are declaring a package variable, you might not want its value injected
into the template at that point.  So instead you could use C<block{..}> execute
multiple statements and not inject the last statement:

	@{[ block {our $temp=1;} }];

=item * Last newline of templates are chomped

Most text editors insert a newline as the last character in a file.  A chomp is
performed before the template is prepared to avoid extra newlines in the output
when using sub templates. If you really need that newline, place an empty line
at the end of your template

=back

=head2  More on Input Variables

If the variables to apply to the template completely change (note: variables
not values), then the aliasing setup during a C<plex> call will not
reflect what you want.

However the C<render> method call allows a hash ref containing values to be
used.  The hash is aliased to the C<%fields> variable in the template.

	my $new_variables={name=>data};
	$template->render($new_variables);

However to use this data the template must be constructed to access the fields
directly:

	my $template='my name is $fields{name} and I am $fields{age}';

Note that the C<%field> is aliased so any changes to it is reflected outside
the template

Interestingly the template can refer to the lexical aliases and the direct
fields at the same time. The lexical aliases only refer to the data provided at
preparation time, while the C<%fields> refer to the latest data provided during
a C<render> call:

	my $template='my name is $fields{name} and I am $age

	my $base_data={name=>"jimbo", age=>10};

	my $override_data={name=>"Eva"};

	my $template=plex $template, $base_data;

	my $string=$template->render($override_data);
	#string will be "my name is Eva and I am 10

As an example, this could be used to 'template a template' with global, slow
changing variables stored as the aliased variables, and the fast changing, per
render data being supplied as needed.


=head1 SECURITY

This module uses C<eval> to generate the code ref for rendering. This means
that your template, being perl code, is being executed. If you do not know what
is in your templates, then maybe this module isn't for you.

Aliasing means that the template has access to variables outside of it.
That's the whole point. So again if you don't know what your templates are
doing, then maybe this module isn't for you

=head1 SEE ALSO

Yet another template module right? 

Do a search on CPAN for 'template' and make a cup of coffee.

=head1 REPOSITORY and BUG REPORTING

Please report any bugs and feature requests on the repo page:
L<GitHub|http://github.com/drclaw1394/perl-template-plex>

=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 by Ruben Westerberg

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, or under the MIT license

=cut
