=head1 NAME

Template::Plex - Templates in (P)erl using (Lex)ical Aliasing

=head1 SYNOPSIS

Import C<plex> and C<plx> into you package:

	use Template::Plex;

Setup variables/data you want to alias:

	my $vars={
		size=>"large",
		slices=>8,
		people=>[qw<Kim Sam Harry Sally>
		]
	};
	local $"=", ";

Write a template:

	#Contents of my_template.plex
	
	@{[ init {
		use Time::HiRes qw<time>;
		$title="Mr.";
		}
	]}j
	Dear $title Connery,
	Ordered a $size pizza with $slices slices to share between @$people and
	myself.  That averages @{[$slices/(@$people+1)]} slices each.
	

Load the template with C<plex>:

	my $template= plex "my_template.plex", \%vars;
	$template->setup;


Render it:

	my $output=$template->render;	

	#OUTPUT
	Ordered a large pizza with 8 slices to share between Kim, Sam, Harry,
	Sally and myself.  That averages 1.6 slices each.     
	

Change values and render it again:

	$vars->{size}="extra large";
	$vars->{slices}=12;
	
	$output=$template->render;

	#OUTPUT
	Ordered a extra large pizza with 12 slices to share between Kim, Sam,
	Harry, Sally and myself.  That averages 2.4 slices each.


=head1 DESCRIPTION

This module facilitates the use of perl (not embedded perl) as a text
processing template language and system capable of loading, caching and
rendering powerful templates. 

It implements a couple of subroutines/directives to perform template
loading/management (i.e. C<plex>, C<plx>). Additionally it includes a handful
of directives and options to make mixing code and text simpler (i.e. C<init>,
C<block> and C<jmap>).

The 'lexical' part of this module refers to input variables being lexically
aliased into the template, improving the style and usage.

The complicated boot strap code in this module is abstracted away with
L<Template::Plex::Base>, which can be sub classed to provide extended
functionally.

=head1 MOTIATION


Many templating systems are available, yet none use perl as the template
language?  Perl already has a great text interpolation so why not use it?

Lexical aliasing allows the input variables to be accessed directly by name
(i.e. C<$name>) instead of as a member of a hash ref
(i.e.C<$fields-E<gt>{name}>) or by delimiting with custom syntax (i.e.
C<E<lt>%=name%E<gt>>)

=head1 SYNTAX GENESIS

=head2 Background Basics

We all know how to interpolate variables in to a string in perl:
	
	"This string $uses a $some{variables}"

But how can we easily interpolate a statement, function or method call? We can
use the C<@{[]}> construct:

	"This is a perl string interpolating @{[ map uc, qw<a b c d>]}"

If we need more statements, we can combine with a C<do> statement:

	"This is a perl string interpolating 
	@{[ do {
		my $result="STATEMENTS";
		...
		lc $result;
		}
	]}
	"

=head2 Look a Template!

Combining the above examples, we make a C<Template::Plex> template simply by
removing the outer quoting operators:


	This string $uses a $some{variables}

	This is a perl string interpolating @{[ map uc, qw<a b c d>]}

	This is a perl string interpolating 
	@{[ do {
		my $result="STATEMENTS";
		lc $result;
		}
	]}

A C<Template::Plex> template is just perl! The above is the literal text you
could save to a file and load as a template.

Specifically, it is the subset of perl that's valid between double quotation
operators. 

=head2 Templates That Do More

This is perl, so our templates can do much more than just read variables and
call functions. We can import modules and define our own functions within the
template for example:

	@{[ init {
		use Time::HiRes qw<time>;

		sub my_func{ 1+2 };
		}
	]}

	Calculated @{[my_func]} at @{[time]}

The above uses the C<init> directive which is like C<do> but executes only once
(though the template might be rendered multiple times) and returns an empty
string into the template (see the section later in this document).


=head2 Rendering a Template

Once you have a template written, you loaded using either C<plex> or C<plx>
functions. C<plx> makes it dead simple:
	
	my %vars=(some=>"values"); 
	my $result=plx "path_to_template", \%vars;

And yes you can use these functions to load templates within templates!


Keep reading to see how to use the other directives, functions and options to
write awesome perl templates and execute them effectively 




=head1 API

The C<Template::Plex> API is small and only consists of functions/directives
which are usable within a template directly.

When using the C<plex> function, you will need to consult
L<Template::Plex::Base> and use the C<setup> and C<render> API from that class.

=head2 C<plex>
	
	#In application:
	plex $path, $variables_hash, %options;

	#In a template:
	@{[
		block {	#or: do, init, pl
			my $template=plex $path, $variables_hash, %options;
			$template->setup;
			my $result=$template->render;
		}
	]}
	
Creates a new instance of a template, loaded from a scalar, file path or an
existing file handle. 

It is usable outside of a template when C<use Template::Plex> is specified and
is the main function to load templates from a user program.

It is always available inside a template and allows recursive loading of templates.

Arguments to this function:


=over 

=item C<$path>

This is a required argument.

If C<$path> is a string, it is treated as a file path to a template file. The
file is opened and slurped with the content being used as the template.

If C<$path> is a filehandle, or GLOB ref, it is slurped with the content being
used as the template. Can be used to read template stored in C<__DATA__> for
example

If C<$path> is an array ref, the items of the array are joined into a string,
which is used directly as the template.



=item C<$variables_hash>

This is an optional argument but if present must be an empty hash ref C<{}> or
C<undef>.

The top level items of the C<$variables_hash> hash are aliased into the
template using the key name (key names must be valid for a variable name for
this to operate). This allows an element such as C<$fields{name>}> to be
directly accessible as C<$name> in the template and sub templates.

External modification of the items in C<$variable_hash> will be visible in the
template. This is thee primary mechanism change inputs for subsequent renders
of the template.

In addition, the C<$variables_hash> itself is aliased to C<%fields> variable
(note the %) and directly usable in the template like a normal hash e.g.
C<$fields{name}>

If the C<$variables_hash> is an empty hash ref C<{}> or C<undef> then no
variables will be lexically aliased. The only variables accessible to the
template will be via the C<render> method call.

=item C<%options>

These are non required arguments, but must be key value pairs when used.

Options are stored lexically for access in the template in the variable
C<%options>. This variable is automatically used as the options argument in
recursive calls to C<plex> or C<plx>, if no options are provided.


Currently supported options are:


=over

=item B<root>

C<root> is a directory path, which if present, is prepended to to the C<$path>
parameter if C<$path> is a string (file path).


=item B<no_include>

Disables the uses of the preprocessor include feature. The template text will
not be scanned  and will prevent the C<include> feature from operating.
See C<include> for more details

This doesn't impact recursive calls to C<plex> or C<plx> when dynamically/conditionally
loading templates.

=item C<no_init_fix>

Disables correcting missing init blocks.

If not specified or false, a template file is scanned for a C<@{[init{..}]}
directive. If one is found, the template is not modified. Otherwise, a 'null'
block is added at the beginning of the template.

The added block is not effected by the enabling/disabling of block fix
mechanism.


=item B<no_block_fix>

Disables removing of EOL after a C<@{[]}> when  the closing C<}]> starts on a
new line. Does not effect C<@{[]}> on a single line or embedded with other
text:

	eg	
		
		Line 1
		@{[
			""
		]}		<-- this NL removed by default
		Line 3	
	
In the above example, the default behaviour is to remove the newline after the
closing C<]}> when it is on a separate line. The rendered output would be:


		Line1
		Line3

If block fix was disabled (i.e. C<no_block_fix> was true) the output would be:


		Line1

		Line3



=item B<package>

Specifies a package to run the template in. Any C<our> variables defined in
the template will be in this package.  If a package is not specified, a unique
package name is created to prevent name collisions

=item B<base>

Specifies the base class type of the template. If not specified, templates are
of type C<Template::Plex::Base>. Sub classes must inherit from this class. See
the Sub classing section for more details

=item B<no_alias>

This disables the aliasing of the top level element in the argument hash. All
variables need to be accessed via the C<%fields> hash when this is effect.


=back

=item Return value

The return value is C<Template::Plex::Base> (or subclass) object which can be initialised and rendered using the C<setup> and C<render> methods of that class.

Please refer to L<Template::Plex::Base> for more details.	

=item Example Usage
		my $hash={
			name=>"bob",
			age=>98
		};

		my $template_dir="/path/to/dir";

		my $obj=plex "template.plex", $hash, root=>$template_dir;
		$obj->setup;
		$obj->render;
=back

=back

=head2 C<plx>

	#In application
	plx $path, $variables_hash, %options;

	#In a template
	@{[ plx $path, $variable_hash, %options]}

	#	or

	@{[
		block {	#or: do, init, pl
			my $result=plx $path, $variables_hash, %options;
		}
	]}

This is a wrapper around the C<plex> function to make it very easy to use templates recursively. Arguments are the same as C<plex>.

In addition to loading a template, the C<setup> and C<render> methods are
called on it. 

The result of this function is the rendered template text.

The template is actually only loaded once and cached. Subsequent calls to
C<plx> from the same file/line reuses the same template. This makes looping or
mapping a template possible in a single line:


	my $rendered=
		map {
			$args->{my_field}=$_;	
			plx "my_template_path", $args, %opts;
		} @data;

Makes using recursive templates very easy:

	state $template=plex ...;
	$template->setup;
	$template->render;


	eg
		@{[ plx "path to sub template"]}

Does have the slight overhead of generating cache keys and actually performing
the cache lookup compared to manually caching using C<plex>


=head2 C<include>


	@{[include("path")}]


This is a special directive that replaces the directive with the literal
contents of the file pointed to by path in a similar style to #include in the C
preprocessor. This is a preprocessing step which happens before the template is
prepared for execution. 


If C<root> was included in the options to C<plex>, then it is prepended to
C<path> if defined.

When a template is loaded by C<plex> the processing of this is
subject to the C<no_include> option. If C<no_include> is specified, any
template text that contains the C<@{[include("path")}]> text will result in a
syntax error

=head2 pl

=head2 block

	@{[ block { ... } ]}

		# or 

	@{[ pl { ... }	]}

A subroutine which executes a block just like the built in  C<do>. However it
always returns an empty  string.

When used in a template in the C<@{[]}> construct, arbitrary statements can be
executed. However, as an empty string is returned, perl's interpolation won't
inject anything at that point in the template.

If you DO want the last statement returned into the template, use the built in
C<do>.

	eg
		
		@{[
			# This will assign a variable for use later in the template
			# but WILL NOT inject the value 1 into template when rendered
			pl {
				$i=1;
			}

		]}


		@{[
			# This will assign a variable for use later in the tamplate
			# AND immediately inject '1' into the template when rendered
			do {
				$i=1
			}

		]}

=head2 init

	@{[ init {...} ]}


Similar to a C<block{}> directive. It is used to configure or setup meta data
for a template and return immediately.

Only the first C<init {...}> block in a template will be executed.

The first C<init {...}> block is executed once, even when the template is
rendered multiple times

This is a good location to place C<use> statements;


=head2 plex_clear

	plex_clear;

B<Subject to change>.  Clears all compiled templates from the current level.


=head2 jmap

	jmap {block} $delimiter, @array

Performs a join using C<$delimiter> between each item in the C<@array> after
they are processed through C<block>

Very handy for rendering lists:

	eg
		<ul>
			@{[jmap {"<li>$_</li>"} "\n", @items]}
		</ul>

Note the lack of comma after the block.

=head2 skip

	Template with potential output
	@{[ block {
		skip if $flag;
		}
	]}
	Any more potential output

B<NOTE:>Instead of using this directive directly, please use a C<@{[ init {}]}> instead.

This subroutine prevents the current template from generating rendered output.
Instead it will return an empty string.  Variables can still be manipulated by
template before the C<skip> call.

Useful to conditionally skip the body of a template, but configure the variable
hash for preprocessing in a C<@{[block{...}]}> structure.

=head2 Advanced

=head3 Introspection

	@{[ $self ]}

The current instance of template is stored in the lexically scoped C<$self>
variable, which is directly accessible in a template.

=head3 Subclassing

The class used for templates can be specified as an option to a C<plex> or
C<plx> call.

This will instantiate the template as an object of this type.  The default
class is C<Template::Plex::Base>. A user class must ultimately be a descendent
of this class.

This gives the ability to extend and morph the templating system into some cool
and  wild places.

Please refer to L<Template::Plex::Base> for more details


=head1 FEATURE CHEAT SHEET

=over

=item * Templates can contain a initialisation state

	@{[
		init {
			# Nomral perl code here will only execute once
		}
	]}


=item * Templates are compiled into a perl subroutine, with automatic caching (plx)

	Sub/template is loaded only the first time in this map/loop

	@{[map {plx "path_to_template",{}} qw< a b c d e >]}
	
	And rendereds serveral times
		

=item * Lexical and package variables accessed/created within templates

	@{[
		init {
			$input_var//=1; #set default
		}

	}]
	
	Value is $input_var;

=item * Call and create subroutines within templates:

	@{[
		init {
			sub my_great_calc {
				my $input=shift;
				$input*2/5;
			}
		}

	}]

	Result of calculation: @{[my_great_calc(12)]}

=item * 'Include' Templates within templates easily:
	
	@{[include("path_to_file")]}

=item * Recursive sub template loading
	
	@{[plx "path_to_sub_template"]}

=item * Conditional rendering

	@{[ $flag and $var]}

	@{[ $flag?$var:""]}
	
	@{[
		pl {
			if($flag){
				#do stuff	
			}
		}
	]}

=item * Lists/Loops/maps
	
	template interpolates @$lists directly
	
	Items that are ok:
	 @{[
	 	do {
			#Standard for loop
			my $output;
			for(@$items){
				$output.=$_."\n" if /ok/;
			}
			$output;
		}
	}]

	More ok items:
	@{[map {/ok/?"$_\n":()} @$items]}

	

=item * C<use> other modules directly in templates:

	@{[
		init {	
			use Time::HiRes qw<time>
		}
	]}

	Time of day right now: @{[time]}

=item * Advanced templating with subclasses (in v0.4)

	Build your own relational templates on top of Template::Plex::Base. Focus on
	the your logic instead of dealing with template nitty gritty

=back



=head1 FILTERS

Previous versions of this module did a C<use> of L<String::Util> automatically
in each template. This has been removed. Please use the B<use> option when
using C<plex>/C<plx> or simply add C<use String::Util> in an C<init> or
C<block> section in your template.





=head1 TIPS ON USAGE

=head2 Potential Pitfalls

=over 

=item * Remeber to set C<$"> locally to your requied seperator

The default is a space, however when generating HTML lists for example,
a would make it easier to read:

	#Before executing template
	local $"="\n";

	plex ...

Or alternatively use C<jmap> to explicitly set the interpolation separator each time

=item * Aliasing is a two way steet

Changes made to aliased variables external to the template are available inside
the template (one of the main tenets of this module)

Changes make to aliased variables internal to the template are available outside
the template.

=item * Unbalanced Delimiter Pairs

Perl double quote operators are smart and work on balanced pairs of delimiters.
This allows for the delimiters to appear in the text body without error.

However if your template doesn't have balanced pairs (i.e. a missing "}" in
javascript/c/perl/etc), the template will fail to compile and give a strange
error.

If you know you don't have balanced delimiters, then you can escape them with a
backslash

Currently L<Template::Plex> delimiter pair used is B<{ }>.  It isn't changeable in
this version.

=item  * Are you sure it's one statement?

If you are having trouble with C<@{[...]}>, remember the result of the last
statement is returned into the template.

Example of single statements

	@{[time]}			#Calling a sub and injecting result
	@{[$a,$b,$c,time,my_sub]}	#injecting list
	@{[our $temp=1]}		#create a variable and inject 
	@{[our ($a,$b,$c)=(7,8,9)]}	#declaring a

If you are declaring a package variable, you might not want its value injected
into the template at that point.  So instead you could use C<block{..}>  or
C<pl{..}> to execute multiple statements and not inject the last statement:

	@{[ pl {our $temp=1;} }];

=item * Last newline of templates are chomped

Most text editors insert a newline as the last character in a file.  A chomp is
performed before the template is prepared to avoid extra newlines in the output
when using sub templates. If you really need that newline, place an empty line
at the end of your template

=back

=head2  More on Input Variables

If the variables to apply to the template completely change (note: variables
not values), then the aliasing setup during a C<plex> call will not
reflect what you want.

However the C<render> method call allows a hash ref containing values to be
used.  The hash is aliased to the C<%fields> variable in the template.

	my $new_variables={name=>data};
	$template->render($new_variables);

However to use this data the template must be constructed to access the fields
directly:

	my $template='my name is $fields{name} and I am $fields{age}';

Note that the C<%field> is aliased so any changes to it is reflected outside
the template

Interestingly the template can refer to the lexical aliases and the direct
fields at the same time. The lexical aliases only refer to the data provided at
preparation time, while the C<%fields> refer to the latest data provided during
a C<render> call:

	my $template='my name is $fields{name} and I am $age

	my $base_data={name=>"jimbo", age=>10};

	my $override_data={name=>"Eva"};

	my $template=plex $template, $base_data;

	my $string=$template->render($override_data);
	#string will be "my name is Eva and I am 10

As an example, this could be used to 'template a template' with global, slow
changing variables stored as the aliased variables, and the fast changing, per
render data being supplied as needed.


=head2 Security

This module uses C<eval> to generate the code for rendering. This means that
your template, being perl code, is being executed. If you do not know what is
in your templates, then maybe this module isn't for you.

Aliasing means that the template has write access to variables outside of it.
So again if you don't know what your templates are doing, then maybe this
module isn't for you


=head1 ISSUES 

Debugging templates could be much better

Unless specifically constructed to write to file, templates are completely
processed in memory.

C<plx> caching will not be effective with literal templates unless they are
stored in an anonymous array.
	


=head1 SEE ALSO

Yet another template module right? 

Do a search on CPAN for 'template' and make a cup of coffee.

=head1 REPOSITORY and BUG REPORTING

Please report any bugs and feature requests on the repo page:
L<GitHub|http://github.com/drclaw1394/perl-template-plex>

=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 by Ruben Westerberg

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, or under the MIT license

=cut
