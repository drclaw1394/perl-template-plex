=head1 NAME

Template::Plex - Templates with Perl and Lexical Aliasing

=head1 SYNOPSIS

	use Template::Plex;

	#Data for templates alias and access
	my $base_data={name=>"James", age=>"12", fruit=>"banana"};

	my $inline_template='$name\'s age $age and favourite fruit is $fruit'

	my $ren=plex [$inline_template], $base_data, $root;

	#	or

	my $ren=plex $path_to_a_file, $base_data, $root;

	# 	or

	my $ren=plex $file_handle, $base_data, $root;


	#Render with the values aliased in $base_data
	$render->();		
	#
	#=> 	James's age is 12 and favourite fruit is banana

	#Update the data, 
	$base_data->{qw<name,fruit>}=qw<John apple>;

	#Rendering again will use updated aliased values
	$render->();		
	#
	#=>	John's age is 12 and favourite fruit is apple


=head1 DESCRIPTION

A very small templating mechanism using perl as the template language. No, not
embedded perl, just perl.  As perl is doing the heavy lifting in the syntax
deparment, this module basically implements a 'shim' to make the perl languge
work as a template language.

Its key goals and features are:

=over

=item * Templates are written in perl syntax

=item * Lexical aliasing for performance and style

=item * 'Include' Templates within templates easily

=back

To achieve these goals, this module uses the experimental feature
B<refaliasing> which may or may not be around int later perl versions


=head1 MOTIATION

=over

=item *

So many templating systems available, none use perl as the template language

=item * 

The perl syntax C<@{[...]}>  to execute aritary statements in a double quoted
string is only 1 more character then many other template langages custom
syntax. Could be a consise approach to templating.

=item * 

I wanted to use lexical aliasing as it can have good performance and
style benefits. 

=item * 

Other templating system are overwhellming. Something consice would be nice

=back

=head1 API

=head2 C<plex>

	plex $path, $hash_ref, %options

=over 

=item C<$path>

If C<$path> is a string, it is treated as a file path to a template file. The file is opened and slurped with the content being used as the template

If C<$path> is filehandle, or GLOB ref, it is slurped. Can be used to read C<__DATA__> containing a tempalte

If C<$path> is an array ref, the items of the array are joined into a stirng, which is used directly as the template.

=item C<$hash_ref>

The C<$hash_ref> provides variables to the template. Using refaliasing, it is aliased to C<%fields> hash in the render subrotine. Fields are accessable as a normal hash eg C<$fields{name}>


The top level items of the C<%fields> hash are also aliased into the render, using , using the key name. Note the key names must be valid for a variable name for this to operate

=item Options

These are non required arguments, but must be key value pairs when used. Currently supported options are

Options are stored lexically in the the rendering sub for recursive C<plex> calls within a tempalte

=over

=item B<root>

C<root> is a directory path, which if present, is prepended to to the C<$path>
parameter.  


=item B<no_include>

Disables the uses of the preprocessor include feature. The template text will not be scanned and C<!{[include($path)]}> entries will not be replaced with text content located at C<$path>

This doesn't impact recursive calls to C<plex> to dynamically/conditionally include templates.

=back

=item Return value

The return value is subroutine reference, which when executed
fills/executes the template with data.

	eg
		my $hash={
			name=>"bob",
			age=>98
		};
		my $template_dir="/path/to/dir";

		my $renderer=plex "template.plex", $hash, root=>$template_dir;


		#/path/to/dir/template.plex
		My name is $name and my age is $age

In this example the hash elements C<{name}> and C<{age}> are aliased to lexical variables C<$name> and C<$age> which are directly accessable to the template.


=back

=head2 C<include>

	@{[include($path)}]

	where $path is path to template file to inject

This special 'subroutine call' is replaced with the contents of the template at C<$path>. Once it is replaced, any subsequent instances are also processed recursively.

This API is only available in templates. The C<$path> has the current C<$root> active in the template prepended if it is defined.

When a template is loaded by C<plex> the processing of this is subject to the C<no_include> option

=head1 PLEX TEMPLATE SYNTAX

Well, its just perl. Seriously. But if you arn't grasping the concept just yet,
a L<Template::Plex> template is a perl program with the two following
constraints:

=over 

=item * The program consists only of perl syntax permissible in a double quoted string

=item * The outermost double quote operators are ommited from the program/template

=back

This is best illustrated by example. Suppose the following text is stored in a file or in the C<__DATA__ > section:

	The pot of gold at the end of the rainbow has $amount gold coins
	As for the rainbow, the colors are:
	@{[ map ucfirst."\n", @$colors ]}
	Good day!

Everthing in the text is valid syntax in double quote operator, but the outer double quote operateor is ommited.

Or in otherwords, the template looks like plain text, but with double quoted added, it is valid perl code.

Neat!

Following sections show example of particular scenarios

=head2 Access to Existing Scalars, Arrays and Hashes

	This template uses a $scalar and it will also
	access the array element $array->[$index]
	Accessing element $hash->{key} just for fun


=head2 Executing a single (or list) of Statements

To achieve this, a neat trick is to dereference an inline reference to an
annonynous array. That is C<@{[...]}>. The contents of the array is then the
result of the statements.  Sounds like a mouthful, but it is only a couple of
braces and lets you do some powerful things:

	Calling a subrotine @{[ my_sub() ]}
	Declaring a variable @{[ my $variable=1; ]};	
	Doing math a + b = @{[ $a+$b ]}
	Building an array @{[ uc("red"),uc("blue")]}
	Mapping @{[ join "\n", map uc, @items]}
	

=head2 Executing Multiple Statements

When a single statement won't do, the C<do{}> construct executes a block, which
can have any number of statements and returns the last statement executed into
the template

	Executing multiple statments @{[ do {
	 	my $a=1; 
		$a++; 
		($a,-$a)

	} ]} in this template

=head2 Using/Requiring Modules

Again standard perl syntax for the win

	Template will call hi res time 
	The time is: @{[ time ]}
	@{[ BEGIN {
		use Time::HiRes qw<time>;
		}
	]}

=head2 Declaring Variables

Variables can be declared in the C<@{[..}]> container. 
package variables..

lexical



=head1 MORE ON LEXICAL ALIASING

Any keys present in the hash when C<plex> is called are used to construct
lexical variables which are aliases to the hash elements of the same key name.
The hash itself is also aliased to a variable called C<%fields> 

So for a C<$base_data> hash like this:

	my $base_data={name=>"jimbo", age=>10};

The template can access the fields "name" and age like this:

	my $template='my name is $name an I am $age';

or like this:
	
	my $template='my name is $fields{name} and I am $fields{age}';

The first uses the lexical variables to skip the hash lookup, and simpler
style.  The caveat is that all fields must exist at the time the template is
prepared.

To change the values and render the template, the same C<$base_data> variable
must be manipulated. ie

	$base_data->{name}="Tim";
	$render->();

This still performs no hash lookups in the rendering and is a very quick way of
rendering the changing data.


=head2 NOT USING LEXICAL ALIASING 

If the data to apply to the template completely changes, it can be passed as a
hash ref to the render code reference.

	my $new_variable={name=>data};
	$render->($new_variable);

However to use this data the template must be constructed to access the fields
directly:

	my $template='my name is $fields{name} and I am $fields{age}';

=head2 HYBRID ACCESS

This is interesting. The template can refer to the lexical aliases and the
direct fields at the same time. The lexical aliases only refer to the data
provided at preparation time, while the field refer to the latest data
provided:

	my $template='my name is $fields{name} and I am $age
	my $base_data={name=>"jimbo", age=>10};
	my $override_data={name=>"Eva"};

	my $render=plex $template, $base_data;
	my $string=$render($override_data);
	#string will be "my name is Eva and I am 10


=head1 SECURITY

This module uses C<eval> to generate the code ref for rendering. This means
that your template, being perl code, is being executed. If you do not know what
is in your templates, then maybe this module isn't for you.

To mitigate the security risk, the rendering code refs should be generated  and
cached, so they are not needing to be run during normal execution. That will
provide faster rendering and also, prevent unknown templates from accidentally
being executed.


=head1 SEE ALSO

Yet another template module right? 

Do a search on CPAN for 'template' and make a cup of coffee.


=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2021 by Ruben Westerberg

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, or under the MIT license

=cut
